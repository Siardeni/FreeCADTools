# -*- coding:Utf-8 -*-
######################################################
# Programme Python type                              #
# Auteur : Nicolas Tuffereau, Angers, decembre 2015  #
# Licence : GPL                                      #
######################################################


# Reste à faire
# Identifier tube cintrés
# Platine
# Tôles pliées





#####################################
# Importation de fonctions externes :

#from os import *
import FreeCAD, FreeCADGui, Part, Draft, math, MeshPart, Mesh, Drawing, DraftGeomUtils, WorkingPlane
from FreeCAD import Base
App=FreeCAD
Gui=FreeCADGui

tolerance=0.000001

#Copie Macro WorkFeature

def intersecPerpendicularLine(A, B, C, info=0):
    """ Return the intersection between the Line L defined by A and B
    and the Line perpendicular crossing the point C.
    """
    # L is the line defined by 2 points A(ax, ay, az) and B(bx, by, bz), and
    # may be also defined as the line crossing A(ax, ay, az) and along the 
    # direction AB = U(bx-ax, by-ay, bz-az)
    # If U(ux, uy, uz) = U(bx-ax, by-ay, bz-az) the Line L is the set of 
    # points M as defined by eq(1):
    # Vector(MA) = k * Vector(U)
    # with k Real 
    if A == B:
        return None
    ax, ay, az = A.x, A.y, A.z
    bx, by, bz = B.x, B.y, B.z
    cx, cy, cz = C.x, C.y, C.z
    ux, uy, uz = bx - ax, by - ay, bz - az
    #U = App.Vector(ux, uy, uz)
    # We look for T(tx, ty, tz) on the Line L
    # eq(1) in parametric form; k exists and follows eq(2):
    # tx = ax + k * ux 
    # ty = ay + k * uy
    # tz = az + k * uz
    
    # and vector V(vx, vy, vz) defined by point C and point T
    # vx, vy, vz = tx - cx, ty - cy, tz - cz
    # V must be perpendicular to the Line L 
    # We consider Dot product between U and V and give us eq(3) 
    # U.V = 0
    # so ux * vx + uy * vy + uz * vz = 0
    # ux * (tx - cx) + uy * (ty - cy) + uz * (tz - cz) = 0
    # ux * (ax + k * ux  - cx) + uy * (ay + k * uy - cy) + uz * (az + k * uz  - cz) = 0
    # ux*ax + ux*(k*ux) - ux*cx + uy*ay + uy*(k*uy) - uy*cy +  uz*az + uz*(k*uz) - uz*cz = 0
    if (ux*ux + uy*uy + uz*uz) == 0.0:
        return None
    k = (ux*cx + uy*cy + uz*cz - ux*ax - uy*ay - uz*az)/(ux*ux + uy*uy + uz*uz)   
    tx = ax + k * ux 
    ty = ay + k * uy
    tz = az + k * uz
    T = App.Vector(tx, ty, tz)
    vx, vy, vz = tx - cx, ty - cy, tz - cz
    V = App.Vector(vx, vy, vz)
    distance = math.sqrt(V.dot(V))
    Tprime = T + V
    if info == 1:
        print_point(T, msg="Intersection Point at distance of " +
                    str(distance) + " is : ")
    return T, distance, Tprime

#Print a message on console.   
def print_msg(message):
    """ Print a message on console.
    """
    print message
    App.Console.PrintMessage( message + "\n")

def print_point(point, msg=""):
    """ Print x,y and z of a point:vector.
    """
    if point.__class__.__name__ != "Vector":
        print_msg("Not a Vector to print !")
        return
    #print_msg(str(point))
    #m_type = point.__class__.__name__
    #print_msg(str(m_type))
    print_msg(str(msg) +
              "x =" + str(point.x) + ", "
              "y =" + str(point.y) + ", "
              "z =" + str(point.z))
    return

def centerLinePoint(edge,info=0):
    """ Return the center point of the Line.
    """
    center = None
    #VVector_A=edge.valueAt( 0.0 )
    Vector_A = edge.Vertexes[0].Point
    if info != 0:
        print_point(Vector_A,"Origin of line selected is : ") 
    #Vector_B=edge.valueAt( edge.Length )
    Vector_B = edge.Vertexes[-1].Point
    if info != 0:
        print_point(Vector_B,"End of line selected is : ") 
    Vector_MidPoint = Vector_B + Vector_A
    center = Vector_MidPoint.multiply(0.5)
    if info != 0:
        print_point(center,"Center of line selected is : ") 
    return center

#
def GetSection(Sol):
	EdgesSol=Sol.Shape.Edges
	FacesSol=Sol.Shape.Faces
	#~ Lengths=[]
	#~ for edge in Edges:
		#~ Lengths.append(edge.Length)
	#---------------
	#Recherche de l'arrête la plus longue
	HighLength=0.0
	No=0
	n=0
	for edge in EdgesSol:
		if edge.Length>HighLength:
			HighLength=edge.Length
			No=n
		n=n+1
	#---------------
	#Recherche de toutes les arrêtes parallèles à la plus longue
	ParallelEdges=[]
	n=0
	VB=(EdgesSol[No].Curve.EndPoint -EdgesSol[No].Curve.StartPoint).normalize()
	for edge in EdgesSol:
		if edge.curvatureAt(0)==0.0:
			VA = (edge.Curve.EndPoint - edge.Curve.StartPoint).normalize()
			if abs((VA.cross(VB)).Length) <= tolerance:
				ParallelEdges.append(n)
				#~ Part.show(EdgesSol[n])
		n=n+1	
	#~ LongiFaces=[]
	#~ n=0
	#~ for face in FacesSol:
		#~ e=0
		#~ for edge in face.Edges:
			#~ if edge.curvatureAt(0)==0.0:
				#~ for pe in ParallelEdges:
					#~ if abs(EdgesSol[pe].Curve.StartPoint.x-edge.Curve.StartPoint.x)<=tolerance \
						#~ and abs(EdgesSol[pe].Curve.StartPoint.y-edge.Curve.StartPoint.y)<=tolerance \
							#~ and abs(EdgesSol[pe].Curve.StartPoint.z-edge.Curve.StartPoint.z)<=tolerance \
								#~ and abs(EdgesSol[pe].Curve.EndPoint.x-edge.Curve.EndPoint.x)<=tolerance \
									#~ and abs(EdgesSol[pe].Curve.EndPoint.y-edge.Curve.EndPoint.y)<=tolerance \
										#~ and abs(EdgesSol[pe].Curve.EndPoint.z-edge.Curve.EndPoint.z)<=tolerance :
											#~ and abs(EdgesSol[pe].curvatureAt(0)-edge.curvatureAt(0))<=tolerance \
												#~ and abs(EdgesSol[pe].curvatureAt(1)-edge.curvatureAt(1))<=tolerance :
													#~ e=e+1
													#~ Part.show(EdgesSol[pe])
		#~ if e>=2:
			#~ LongiFaces.append(n)
			#~ Part.show(FacesSol[n])
		#~ n=n+1
	#---------------
	#Recherche des deux faces d'extrémitées
	ExtremFaces=[]
	VertexesHighEdge=EdgesSol[No].Vertexes
	n=0
	for face in FacesSol:
		nb=0
		for vertexe in VertexesHighEdge:
			if abs(vertexe.distToShape(face)[0])<=tolerance:
				nb=nb+1
		if nb==1:			
			ExtremFaces.append(n)
			#~ Part.show(FacesSol[n])
		n=n+1
	#---------------
	#Recherche de l'arrête la plus courte aboutissant sur une face d'extrémité
	LowLength=[HighLength,0]
	n=0
	for edge in ParallelEdges:
		for vertexe in EdgesSol[edge].Vertexes:
			if abs(vertexe.distToShape(FacesSol[ExtremFaces[0]])[0])<=tolerance:
				if EdgesSol[edge].Length <= LowLength[0]:
					LowLength[0]=EdgesSol[edge].Length
					LowLength[1]=n
		n=n+1
	#~ Part.show(EdgesSol[ParallelEdges[LowLength[1]]])
	
	#---------------
	#Création d'un plan normal à la courbe précédement trouvée puis section en testant qu'il n'y a qu'une face.
	#si + de 1 face : présence de trous. Pas de test pour savoir si présence d'un usiange non traversant dans la
	#section.... reste à chercher (piste : toutes les faces coupé doivent donné un résultat unique...)
	#Encore une fois fortement inspiré de la macro WorkFeature
	
	LowEdge=EdgesSol[ParallelEdges[LowLength[1]]]
	V1=centerLinePoint(LowEdge,0)
	#~ Part.show(LowEdge)
	
	Vector_A = LowEdge.valueAt( 0.0 )
	Vector_B = LowEdge.valueAt( LowEdge.Length )
	Vector_C = V1
	
	Plane_Normal = Vector_B - Vector_A
    
	Vector_T=Vector_C
    
	Plane_Point = Vector_T +  (Vector_C - Vector_T).multiply(0.5)
			
	Plane_face=Part.makePlane(HighLength,HighLength,Plane_Point, Plane_Normal )
	Plane_Center = Plane_face.CenterOfMass
	Plane_Translate =  Plane_Point - Plane_Center
	Plane_face.translate( Plane_Translate )
	#~ plane.Shape = Plane_face
	#~ Part.show(Plane_face)

	Section=Plane_face.common(Sol.Shape)
	
	if len(Section.Faces)==1:
		TestBarre=True
		
	# Reste à implémanter le test de validation...
	
	return [Section,HighLength,TestBarre]
	
def TypeSection(Section):
	
	NbEdge=len(Section.Edges)
	
	NbWires=len(Section.Wires)
	#si 2 profil fermé, si 1 profil ouvert
	
	NbDroite=0
	for edge in Section.Edges:
		if edge.curvatureAt(0.0)<tolerance:
			NbDroite=NbDroite+1
		
	Type=[FamilleProfile(NbEdge,NbWires,NbDroite),Section]
	#~ print Type[0]
	if Type[0]!= False:
		if Type[0][4]==1:
			Profil=Profil01(Type)	
		if Type[0][4]==2:
			Profil=Profil02(Type)	
		if Type[0][4]==3:
			Profil=Profil03(Type)	
		if Type[0][4]==4:
			Profil=Profil04(Type)	
		if Type[0][4]==5:
			Profil=Profil05(Type)	
		if Type[0][4]==6:
			Profil=Profil06(Type)	
		if Type[0][4]==7:
			Profil=Profil07(Type)	
		if Type[0][4]==8:
			Profil=Profil08(Type)	
		if Type[0][4]==9:
			Profil=Profil09(Type)	
		if Type[0][4]==10:
			Profil=Profil10(Type)	
		if Type[0][4]==11:
			Profil=Profil11(Type)	
		if Type[0][4]==12:
			Profil=Profil12(Type)	
		if Type[0][4]==13:
			Profil=Profil13(Type)	
	
	return Profil
		
		
def Profil01(type):
	
	dimIPE=[]
	dimIPN.append(["AA",80*,4.9,78,46,3.2,4.2,5,6.31,69.6,59.6,-,-,-,0.325,65.62,])
	dimIPN.append(["A",80/*,5,78,46,3.3,4.2,5,6.38,69.6,59.6,-,-,-,0.325,64.9,])
	dimIPN.append(["N",80*,6,80,46,3.8,5.2,5,7.64,69.6,59.6,-,-,-,0.328,54.64,])
	dimIPN.append(["AA",100*,6.7,97.6,55,3.6,4.5,7,8.56,88.6,74.6,-,-,-,0.396,58.93,])
	dimIPN.append(["A",100/*,6.9,98,55,3.6,4.7,7,8.8,88.6,74.6,-,-,-,0.397,57.57,])
	dimIPN.append(["N",100*,8.1,100,55,4.1,5.7,7,10.3,88.6,74.6,-,-,-,0.4,49.33,])
	dimIPN.append(["AA",120*,8.4,117,64,3.8,4.8,7,10.7,107.4,93.4,-,-,-,0.47,56.26,])
	dimIPN.append(["A",120,8.7,117.6,64,3.8,5.1,7,11,107.4,93.4,-,-,-,0.472,54.47,])
	dimIPN.append(["N",120,10.4,120,64,4.4,6.3,7,13.2,107.4,93.4,-,-,-,0.475,45.82,])
	dimIPN.append(["AA",140*,10.1,136.6,73,3.8,5.2,7,12.8,126.2,112.2,-,-,-,0.546,54.26,])
	dimIPN.append(["A",140,10.5,137.4,73,3.8,5.6,7,13.4,126.2,112.2,-,-,-,0.547,52.05,])
	dimIPN.append(["N",140,12.9,140,73,4.7,6.9,7,16.4,126.2,112.2,-,-,-,0.551,42.7,])
	dimIPN.append(["AA",160*,12.1,156.4,82,4,5.6,7,15.4,145.2,131.2,-,-,-,0.621,50.4,])
	dimIPN.append(["A",160,12.7,157,82,4,5.9,9,16.2,145.2,127.2,-,-,-,0.619,48.7,])
	dimIPN.append(["N",160,15.8,160,82,5,7.4,9,20.1,145.2,127.2,-,-,-,0.623,39.47,])
	dimIPN.append(["AA",180*,14.9,176.4,91,4.3,6.2,9,19,164,146,10,48,48,0.693,46.37,])
	dimIPN.append(["A",180,15.4,177,91,4.3,6.5,9,19.6,164,146,10,48,48,0.694,45.15,])
	dimIPN.append(["N",180,18.8,180,91,5.3,8,9,23.9,164,146,10,48,48,0.698,37.13,])
	dimIPN.append(["O",180,21.3,182,92,6,9,9,27.1,164,146,10,50,50,0.705,33.12,])
	dimIPN.append(["AA",200*,18,196.4,100,4.5,6.7,12,22.9,183,159,10,54,58,0.763,42.51,])
	dimIPN.append(["A",200,18.4,197,100,4.5,7,12,23.5,183,159,10,54,58,0.764,41.49,])
	dimIPN.append(["N",200,22.4,200,100,5.6,8.5,12,28.5,183,159,10,54,58,0.768,34.36,])
	dimIPN.append(["O",200,25.1,202,102,6.2,9.5,12,32,183,159,10,56,60,0.779,31.05,])
	dimIPN.append(["AA",220*,21.2,216.4,110,4.7,7.4,12,27,201.6,177.6,12,60,62,0.843,39.78,])
	dimIPN.append(["A",220,22.2,217,110,5,7.7,12,28.3,201.6,177.6,12,60,62,0.843,38.02,])
	dimIPN.append(["N",220,26.2,220,110,5.9,9.2,12,33.4,201.6,177.6,12,60,62,0.848,32.36,])
	dimIPN.append(["O",220,29.4,222,112,6.6,10.2,12,37.4,201.6,177.6,10,58,66,0.858,29.24,])
	dimIPN.append(["AA",240*,24,9,236,4,120,4,8,8,15,31,7,220,4,190,4,12,64,68,0,917,36,86,])
	dimIPN.append(["A",240,26,2,237,120,5,2,8,3,15,33,3,220,4,190,4,12,64,68,0,918,35,1,])
	dimIPN.append(["N",240,30,7,240,120,6,2,9,8,15,39,1,220,4,190,4,12,66,68,0,922,30,02,])
	dimIPN.append(["O",240,34,3,242,122,7,10,8,15,43,7,220,4,190,4,12,66,70,0,932,27,17,])
	dimIPN.append(["A",270,30,7,267,135,5,5,8,7,15,39,2,249,6,219,6,16,70,72,1,037,33,75,])
	dimIPN.append(["N",270,36,1,270,135,6,6,10,2,15,45,9,249,6,219,6,16,72,72,1,041,28,86,])
	dimIPN.append(["O",270,42,3,274,136,7,5,12,2,15,53,8,249,6,219,6,16,72,72,1,051,24,88,])
	dimIPN.append(["A",300,36,5,297,150,6,1,9,2,15,46,5,278,6,248,6,16,72,86,1,156,31,65,])
	dimIPN.append(["N",300,42,2,300,150,7,1,10,7,15,53,8,278,6,248,6,16,72,86,1,16,27,46,])
	dimIPN.append(["O",300,49,3,304,152,8,12,7,15,62,8,278,6,248,6,16,74,88,1,174,23,81,])
	dimIPN.append(["A",330,43,327,160,6,5,10,18,54,7,307,271,16,78,96,1,25,29,09,])
	dimIPN.append(["N",330,49,1,330,160,7,5,11,5,18,62,6,307,271,16,78,96,1,254,25,52,])
	dimIPN.append(["O",330,57,334,162,8,5,13,5,18,72,6,307,271,16,80,98,1,268,22,24,])
	dimIPN.append(["A",360,50,2,357,6,170,6,6,11,5,18,64,334,6,298,6,22,86,88,1,351,26,91,])
	dimIPN.append(["N",360,57,1,360,170,8,12,7,18,72,7,334,6,298,6,22,88,88,1,353,23,7,])
	dimIPN.append(["O",360,66,364,172,9,2,14,7,18,84,1,334,6,298,6,22,90,90,1,367,20,69,])
	dimIPN.append(["A",400,57,4,397,180,7,12,21,73,1,373,331,22,94,98,1,464,25,51,])
	dimIPN.append(["N",400,66,3,400,180,8,6,13,5,21,84,5,373,331,22,96,98,1,467,22,12,])
	dimIPN.append(["O",400,75,7,404,182,9,7,15,5,21,96,4,373,331,22,96,100,1,481,19,57,])
	dimIPN.append(["A",450,67,2,447,190,7,6,13,1,21,85,6,420,8,378,8,24,100,102,1,603,23,87,])
	dimIPN.append(["N",450,77,6,450,190,9,4,14,6,21,98,8,420,8,378,8,24,100,102,1,605,20,69,])
	dimIPN.append(["O",450,92,4,456,192,11,17,6,21,118,420,8,378,8,24,102,104,1,622,17,56,])
	dimIPN.append(["A",500,79,4,497,200,8,4,14,5,21,101,468,426,24,100,112,1,741,21,94,])
	dimIPN.append(["N",500,90,7,500,200,10,2,16,21,116,468,426,24,102,112,1,744,19,23,])
	dimIPN.append(["O",500,107,506,202,12,19,21,137,468,426,24,104,114,1,76,16,4,])
	dimIPN.append(["A",550,92,1,547,210,9,15,7,24,117,515,6,467,6,24,106,122,1,875,20,36,])
	dimIPN.append(["N",550,106,550,210,11,1,17,2,24,134,515,6,467,6,24,110,122,1,877,17,78,])
	dimIPN.append(["O",550,123,556,212,12,7,20,2,24,156,515,6,467,6,24,110,122,1,893,15,45,])
	dimIPN.append(["A",600,108,597,220,9,8,17,5,24,137,562,514,27,114,118,2,013,18,72,])
	dimIPN.append(["N",600,122,600,220,12,19,24,156,562,514,27,116,118,2,015,16,45,])
	dimIPN.append(["O",600,154,610,224,15,24,24,197,562,514,27,118,122,2,045,13,24,])
	dimIPN.append(["N","750x137",137,753,263,11,5,17,17,175,719,685,27,102,162,2,506,18,28,])
	dimIPN.append(["N","750x147",147,753,265,13,2,17,17,188,719,685,27,104,164,2,51,17,06,])
	dimIPN.append(["N","750x173",173,762,267,14,4,21,6,17,221,718,8,684,8,27,104,166,2,534,14,58,])
	dimIPN.append(["N","750x196",196,770,268,15,6,25,4,17,251,719,2,685,2,27,106,166,2,552,12,96,])
		
	dimHEA=[]
		
	dimHEB=[]
	
	dimHEM=[]
	
def Profil02(type):
	
	dimIPN=[]
	dimIPN.append([80.0,42.0,3.9,5.9,3.9,2.3])
	dimIPN.append([100.0,50.0,4.5,6.8,4.5,2.7])
	dimIPN.append([120.0,58.0,5.1,7.7,5.1,3.1])
	dimIPN.append([140.0,66.0,5.7,8.6,5.7,3.4])
	dimIPN.append([160.0,74.0,6.3,9.5,6.3,3.8])
	dimIPN.append([180.0,82.0,6.9,10.4,6.9,4.1])
	dimIPN.append([200.0,90.0,7.5,11.3,7.5,4.5])
	dimIPN.append([220.0,98.0,8.1,12.2,8.1,4.9])
	dimIPN.append([240.0,106.0,8.7,13.1,8.7,5.2])
	dimIPN.append([260.0,113.0,9.4,14.1,9.4,5.6])
	dimIPN.append([280.0,119.0,10.1,15.2,10.1,6.1])
	dimIPN.append([300.0,125.0,10.8,16.2,10.8,6.5])
	dimIPN.append([320.0,131.0,11.5,17.3,11.5,6.9])
	dimIPN.append([340.0,137.0,12.2,18.3,12.2,7.3])
	dimIPN.append([360.0,143.0,13.0,19.5,13.0,7.8])
	dimIPN.append([380.0,149.0,13.7,20.5,13.7,8.2])
	dimIPN.append([400.0,155.0,14.4,21.6,14.4,8.6])
	dimIPN.append([450.0,170.0,16.2,24.3,16.2,9.7])
	dimIPN.append([500.0,185.0,18.0,27.0,18.0,10.8])
	dimIPN.append([550.0,200.0,19.0,30.0,19.0,11.9])
	dimIPN.append([600.0,215.0,21.6,32.4,21.6,13.0])

	Section=type[1]
	CDG=Section.Faces[0].CenterOfMass
	
	#Recherche de l'arrête la plus longue
	LMax=0.0
	NoMax=0
	n=0
	for edge in Section.Faces[0].Edges:
		if edge.Length>LMax:
			LMax=edge.Length
			NoMax=n
		n=n+1
	#nombre d'arrête = Lmax doit être 2
	n=0
	for edge in Section.Faces[0].Edges:
		if edge.Length-LMax<=tolerance:
			n=n+1
	if n!=2:
		"Problème : "
	#Recherche des 2 arrêtes égales de longueur inférieure
	LMed=0.0
	NoMed=0
	n=0
	for edge in Section.Faces[0].Edges:
		if edge.Length<LMax and edge.Length>LMed:
			LMed=edge.Length
			NoMed=n
		n=n+1
	
	C1=centerLinePoint(Section.Faces[0].Edges[NoMax],0)
	C2=centerLinePoint(Section.Faces[0].Edges[NoMed],0)
	d1=C1.sub(CDG)
	d2=C2.sub(CDG)
	l1=math.sqrt((d1.x)**2+(d1.y)**2+(d1.z)**2)
	l2=math.sqrt((d2.x)**2+(d2.y)**2+(d2.z)**2)
	if l2>l1:
		L1=l2
		L2=l1
		NOMax=NoMed
		NOMed=NoMax
	else :
		L1=l1
		L2=l2
		NOMax=NoMax
		NOMed=NoMed
	Ih=L1*2
	Ib=Section.Faces[0].Edges[NOMax].Length
	Ia=L2*2
	
	TypeIPN="Poutrelle IPN "
	
	
	for mes in dimIPN:
		#~ print "Ih : "+str(Ih)
		#~ print "Ih : "+str(mes[0])
		#~ print "Ib : "+str(Ib)
		#~ print "Ib : "+str(mes[1])
		#~ print "Ia : "+str(Ia)
		#~ print "Ia : "+str(mes[2])
		if abs(Ih-mes[0])<=tolerance and abs(Ib-mes[1])<=tolerance and abs(Ia-mes[2])<=tolerance:
			#~ print "hell"
			TypeIPN=	TypeIPN+str(int(mes[0]))
	#~ print TypeIPN
	return TypeIPN


def Profil03(type):
	
	dimUPN=[]

def Profil04(type):
	
	dimUPE=[]
	
def Profil05(type):
	
	dimCorniereEgaleAcier=[]
	
	dimCorniereInegaleAcier=[]
	
def Profil06(type):	
	
	dimPlat=[]
	
	dimCarre=[]
	
def Profil07(type):
	
	dimTe=[]

def Profil08(type):
	
	dimRond=[]
		
def Profil09(type):
	
	dimTubeRond=[]	
	
def Profil10(type):
	
	dimTubeCarre=[]	
	
	dimTubeRectangle=[]	
	
def Profil11(type):
	
	dimLAlu=[]	

def Profil12(type):
	
	dimUAlu=[]	
	
	dimTAlu=[]	

def Profil13(type):
	
	dimTubeCarreAlu=[]	
	
	dimTubeRectangleAlu=[]	
		
def FamilleProfile(NbArretes,ProfilOuvert,NbArretesDroites):
	
	Famille=[[16,1,12,"IPE IPEA HEA HEB HEM",1],\
	[20,1,12,"IPN",2],\
	[12,1,8,"UPN",3],\
	[10,1,8,"UPE",4],\
	[9,1,6,"Corniere Acier",5],\
	[4,1,4,"Plat Carre",6],\
	[14,1,6,"Te",7],\
	[1,1,0,"Rond",8],\
	[2,2,0,"Tube Rond",9],\
	[16,2,8,"Tube Carre Rectangle acier",10],\
	[6,1,6,"Profil L Alu",11],\
	[8,1,8,"Profil U T Alu",12],\
	[8,2,8,"Tube Carre Rectangle Alu",13]]
	
	TypeProfil=False
	for f in Famille:
		if f[0]==NbArretes and f[1]==ProfilOuvert and f[2]==NbArretesDroites:
			TypeProfil=f
					
	return TypeProfil
	
oldDocumentObjects=App.ActiveDocument.Objects
	
sel=FreeCADGui.Selection.getSelection()

if sel:
	Sections=[]
	TypeSections=[]
	for solide in sel:
		Sections.append(GetSection(solide))
	#~ print Sections	
	for section in Sections:
		if section[2]==True:
			TypeSections.append(TypeSection(section[0]))
	#~ print TypeSections
	#~ print Sections
	n=0
	for section in Sections:
		print str(TypeSections[n])+" Longueur : "+str(section[1])+" mm"
		n=n+1
	
		
else:
	print "Sélectionner des pièces"		


